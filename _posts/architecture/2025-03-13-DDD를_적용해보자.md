
## DDD의 이해
### 타임픽 서비스
최근 DDD에 관심이 생겨 여러 책을 읽었고, 배운 내용을 연습할 겸 예약 서비스를 구축하려고 한다. 이 서비스를 이제부터 타임픽(TimePick)이라고 부르겠다.

타임픽 서비스는 "주최자(Host)가 예약 가능한 시간을 만들면, 참여자(Participant)가 원하는 시간대에 예약하는 서비스"이다.

서비스가 다루는 비즈니스 영역을 `도메인(Domain)`이라고 한다. 도메인은 여러 개의 `서브 도메인(Subdomain)`으로 구성되며, 각각의 서브 도메인이 협력하여 문제를 해결한다. 따라서 각 서브 도메인이 본연의 역할을 수행할 수 있도록 먼저 서브 도메인을 분리해보자.

### 서브 도메인
서브 도메인은 `핵심 도메인`, `지원 도메인`, `인증 도메인`으로 나눠진다.
1. 핵심 도메인 - 예약 관리 
    - 비즈니스의 핵심이 되는 도메인으로 경쟁업체와의 차별성을 가지고 있어야 한다.
    - Schedule (예약 가능한 일정 관리)
    - Booking (예약 신청 및 관리)

2. 지원 도메인 - 사용자 관리
    - 회사의 비즈니스를 지원하는 활동이지만 핵심 도메인과 달리 어떠한 경쟁 우위도 제공하지 않는다. 비교적 CRUD를 구현하는 정도로 간단하다.
    - Host (주최자 정보 관리)
    - Participant (참여자 정보 관리)

3. 인증 도메인 - 인증 및 보안
    - 경쟁력을 제공하지는 않지만 일반적으로 복잡하고 구현하기 어렵다. 이미 많은 솔루션들이 존재하며 최적화나 혁신이 필요없는 경우에 속한다.
    - Authentication (인증)
    - Notification (알림)
    - Payment (결제)


이렇게 비즈니스의 주요 영역을 파악했다면, 이제 이를 모델링해야 한다. 예를 들어 "고객"이라는 개념은 예약을 할 때는 "예약 고객(Participant)"이지만, 결제를 할 때는 "결제 고객(Payer)"이라는 의미로 사용된다. 즉, 문맥(Context)에 따라 같은 용어도 다르게 해석될 수 있다. 이러한 문제를 해결하기 위해 **바운디드 컨텍스트(Bounded Context)** 개념을 적용할 수 있다.

### 바운디드 컨텍스트 
바운디드 컨텍스트는 특정 용어와 개념이 일관되게 적용되는 경계를 의미한다. 서로 다른 바운디드 컨텍스트에서는 같은 용어라도 다른 의미를 가질 수 있다. 예를 들어, 예약 시스템과 결제 시스템에서 "고객(User)"의 정의를 살펴보자.

예약 바운디드 컨텍스트의 고객
```java
package com.example.reservation.domain;

public class User {
    private Long id;
    private String name;
    private String phoneNumber;
    // 기타 예약 관련 필드
}
```

결제 바운디드 컨텍스트의 고객
```java
package com.example.payment.domain;

public class User {
    private Long id;
    private String name;
    private String email;
    private String billingAddress;
    private List<PaymentMethod> paymentMethods;
    // 기타 결제 관련 필드
}
```

같은 "User" 클래스지만, 예약 바운디드 컨텍스트에서는 이름과 전화번호가 중요한 반면, 결제 바운디드 컨텍스트에서는 이메일, 결제 수단, 청구 주소 등이 필요하다. 따라서 하나의 바운디드 컨텍스트에서 정의된 개념을 다른 바운디드 컨텍스트에서 그대로 공유하는 것은 바람직하지 않다.

또한, 하나의 바운디드 컨텍스트에는 하나의 팀만 배정하는 것이 좋다. 이렇게 하면 특정 팀의 요구 사항이 다른 팀의 개발 일정에 영향을 주는 것을 방지할 수 있고, 하나의 변경이 다른 컨텍스트에 미치는 영향을 최소화할 수 있다. 


타임픽의 바운디드 컨텍스트는 다음과 같이 작성할 수 있다. 

| 바운디드 컨텍스트          | 역할 및 책임                  |
|-------------------------|---------------------------------|
| **Reservation Context** | 예약 가능한 일정과 예약 신청 관리의 핵심 비즈니스 처리. 일정 및 예약의 상태, 신청, 승인 관리 등을 수행. |
| **User Context** | 서비스 사용자의 가입, 인증, 사용자 정보 관리 |
| **Notification Context (Optional)** | 예약 신청, 예약 확정, 취소 등 이벤트 발생 시 사용자에게 알림을 전달하는 역할 수행 |
| **Payment Context (Optional)** | 예약 과정에서 발생하는 결제 관련 업무 처리 |


이제 바운디드 컨텍스트가 맡은 책임과 역할을 할 수 있도록 필요한 개념들을 `애그리거트(Aggregate)`를 이용해 정의해보자.

### 애그리거트 
애그리게이트는 하나 이상의 엔티티(Entity)와 값 객체(Value Object)로 구성되며, 트랜잭션 범위를 설정하고 데이터의 일관성을 보장하는 역할을 한다.

바운디드 컨텍스트를 정의하면서 우리는 예약(Reservation)과 관련된 핵심 개념을 도출했다. 이 과정에서 "일정(Schedule)"과 "예약(Booking)"이 주요 엔티티임을 확인할 수 있다. 

애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티이다. 타임픽의 예제를 통해 애그리거트의 루트를 정해보자. 

예약을 생성할 때마다 Schedule의 상태가 변경되어야 하므로, Schedule을 애그리게이트 루트(Aggregate Root)로 정의하고, Booking을 그 내부 엔티티로 포함하는 것이 적절하다.

```
public class Schedule {
    private Long id;
    private Host host;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private List<Booking> bookings;

    public void addBooking(Participant participant) {
        if (isAvailable()) {
            bookings.add(new Booking(participant, this));
        } else {
            throw new IllegalStateException("예약이 불가능합니다.");
        }
    }

    private boolean isAvailable() {
        return bookings.size() < getMaxCapacity();
    }
}
```


