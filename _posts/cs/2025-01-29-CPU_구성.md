---
title: CPU의 코어와 스레드 구성과 구조
excerpt: CPU의 코어와 스레드 구성, 운영체제의 스케줄링 방식, 그리고 자바 스레드와 하드웨어 스레드의 차이를 설명합니다.
permalink: /cpu-구성/
categories: [ CS ]
tags: [ os, 운영체제, cpu, 스레드, 코어 ]
image:
  path: /assets/covers/computer.png
toc: true
published: false
---

CPU의 코어와 스레드 구성, 운영체제의 스케줄링 방식

## 🖥️ CPU 구성
```
+-------------------------------------------+
|                  CPU                      |  <-- 회사
| +--------------+  +--------------+        |
| |    Core 1    |  |    Core 2    |        |  <-- 직원
| | +---------+  |  | +---------+  |        |
| | | Thread 1 | |  | | Thread 3 | |        |  <-- 작업 단위
| | | Thread 2 | |  | | Thread 4 | |        |
| | +---------+  |  | +---------+  |        |
| +--------------+  +--------------+        |
+-------------------------------------------+
```
- CPU는 여러 개의 **코어(Core)** 로 구성되며, 각 코어는 하나 이상의 **스레드(Thread)** 를 실행할 수 있다.
- 코어는 프로세싱 유닛이며, 스레드는 실행 가능한 가장 작은 작업 단위이다.

### 🔍 Q1: 프로그램이 실행될 때 어떤 코어에 어떻게 할당되는가 ? 
- 운영체제(OS)의 스케줄러가 실행할 코어를 선택하며,  APIC(Advanced Programmable Interrupt Controller)를 사용하여 인터럽트(Interrupt) 또는 시스템 요청을 특정 코어에 전달한다.

### 🔍 Q2: 운영체제도 결국 실행되려면 램에 올라와야 하는데 이때는 어떤 CPU의 코어가 이를 알고 처리하는가?
```
1️⃣ BIOS/UEFI가 부팅 프로세스를 시작하고, 첫 번째 실행할 CPU 코어(부트 코어)를 선택  
		⬇
2️⃣ 부트로더(Bootloader)가 운영체제 커널을 RAM에 로드  
		⬇
3️⃣ 첫 번째 코어(Boot Core)가 OS 커널을 실행  
		⬇
4️⃣ 운영체제가 모든 CPU 코어를 활성화하고, 스케줄러를 실행  
		⬇
5️⃣ 운영체제 스케줄러가 운영체제의 주요 기능과 사용자 프로그램을 여러 코어에 배분  
		⬇
6️⃣ 멀티코어 시스템에서 운영체제가 최적의 성능을 위해 작업을 조정하며 실행됨  
```

### 🔍 Q3: 운영체제는 어떻게 스케줄링을 하는가?
- 초기에는 **부트 코어(Boot Core)** 가 OS 로딩을 담당하지만, 운영체제가 부팅된 이후에는 모든 CPU 코어가 작업을 분배받아 실행하게 된다.

```
1️⃣ 실행할 준비가 된 프로세스(스레드)가 대기열(Ready Queue)에 있음
      ⬇
2️⃣ 운영체제(OS)가 스케줄링 알고리즘을 사용하여 실행할 프로세스를 선택
      ⬇
3️⃣ 선택된 프로세스가 CPU에서 실행됨 (Running 상태)
      ⬇
4️⃣ 실행 중인 프로세스가 완료되거나 I/O 요청으로 인해 대기 상태(Blocked)로 이동
      ⬇
5️⃣ CPU가 새로운 프로세스를 실행 (Ready Queue에서 다음 프로세스 선택)
```

## 🎯 코어
```
+-------------------------------------------+
|                코어 (Core)                 |
| +--------------------------------------+  |
| |  🚀 ALU (산술 논리 연산 장치)             |  |
| |  🔢 FPU (부동소수점 연산 장치)            |  |
| |  📊 레지스터 (PC, IR, SP, GPR 등)       |  |
| |  🎛 CU (제어 장치)                     |  |
| +--------------------------------------+  |
+-------------------------------------------+
```
- ALU(Arithmetic Logic Unit): 연산 처리
- FPU(Floating Point Unit): 소수점이 포함된 숫자(부동소수점) 연산을 수행하는 전용 하드웨어 유닛
- CU (Control Unit): 명령어를 해석하고 어떤 연산이 필요한지 판단 후에 ALU, FPU 에게 작업을 할당한다.
- Register: 연산에 필요한 데이터를 저장하는 초고속 임시 메모리로 ALU, FPU가 연산할 데이터를 저장하고 연산이 끝난 결과도 잠시 저장한다.
	- PC(Program Counter): 실행할 명령어의 메모리 주소를 저장
	- IR(Instruction Register): 현재 실행 중인 명령어를 저장
	- GPR(General Purpose Register): 연산에 사용될 데이터 저장 
	- SP(Stack Pointer): 스택 메모리의 위치를 저장 




## 🧵 **스레드 (Thread)**

스레드는 **프로세스 내에서 실행 가능한 가장 작은 작업 단위**
하나의 프로세스는 여러 개의 스레드를 가질 수 있으며, 각 스레드는 독립적으로 실행된다.


### 🔹 **커널 스레드(Kernel Thread)와 유저 스레드(User Thread)**

#### 1️⃣ **커널 스레드 (Kernel Thread)**

- **운영체제(OS)** 가 직접 관리하는 스레드
- 커널에서 스레드의 **생성, 스케줄링, 제거** 를 담당
- **문맥 전환(Context Switching)** 비용이 높지만, OS가 직접 스케줄링하기 때문에 **안정성**이 높음
	- 문맥 전환이 발생하면 **커널 모드(Kernel Mode)** 로 전환 후, OS가 스케줄링을 수행



#### 2️⃣ **유저 스레드 (User Thread)**

- **사용자 레벨의 라이브러리(User-Level Thread Library)** 를 통해 관리됨
- 문맥 전환 비용이 낮아 **속도가 빠름**, 유연한 스케줄링 가능
	- 운영체제의 개입 없이 **사용자 프로그램이 직접 스케줄링을 수행**
- 그러나, **OS가 개별 유저 스레드를 인식하지 않기 때문에** 한 스레드가 블록되면 전체 프로세스가 멈출 위험이 있음


📌 **커널 스레드 vs 유저 스레드**

|**특징**|**커널 스레드**|**유저 스레드**|
|---|---|---|
|**관리 주체**|운영체제(OS)|사용자 프로그램|
|**속도**|상대적으로 느림 (문맥 전환 비용 큼)|빠름 (문맥 전환 비용 적음)|
|**안정성**|높음 (OS 스케줄링)|낮음 (블로킹 문제)|
|**OS 인식**|개별 스레드 인식|인식하지 않음|

---

### 🔥 **Q1: 자바에서 생성하는 스레드와 CPU의 스레드의 차이점은?**

자바 애플리케이션에서 스레드를 생성할 때와 실제 CPU에서 실행되는 스레드는 서로 다른 개념이다. 이를 이해하기 위해 **하드웨어 스레드** 와 **소프트웨어 스레드** 를 구분할 필요가 있다.

#### 🔹 **하드웨어 스레드 (Hardware Thread)**

- **CPU 코어** 내에서 병렬 처리를 지원하는 단위
- 인텔의 **하이퍼스레딩 (Hyper-Threading)** 기술처럼, 하나의 코어에서 두 개의 하드웨어 스레드를 동시에 처리 가능 
	-  ALU와 FPU 등 일부 하드웨어 리소스를 공유하므로 성능이 완전히 두 배가 되지는 않는다. ALU를 사용하고 있지 않으면 또 다른 스레드가 ALU를 사용하는 방식으로 동작하기 때문. 

#### 🔹 **소프트웨어 스레드 (Software Thread)**

- 운영체제나 애플리케이션(JVM)에서 **동적으로 생성**되는 스레드
- **운영체제의 스케줄러** 에 의해 **하드웨어 스레드** 와 매핑되어 실행

#### ✅ **자바에서의 스레드 생성 및 실행 흐름**

```
1️⃣ Java에서 Thread 객체 생성 (`new Thread()`)
      ⬇
2️⃣ JVM이 OS에 새로운 스레드 생성 요청 (`t1.start()`)
      ⬇
3️⃣ 운영체제(OS)가 소프트웨어 스레드를 관리하고, 적절한 하드웨어 스레드에 매핑
      ⬇
4️⃣ CPU의 특정 하드웨어 스레드에서 실제 실행됨
```

- **Java Thread**: 자바 애플리케이션 레벨에서 관리되는 **소프트웨어 스레드**
- **CPU Thread (하드웨어 스레드)**: 실제 물리적인 연산을 수행하는 **하드웨어 레벨**의 스레드

#### 📌 **예시로 보는 흐름**

- **Java 애플리케이션**: `Thread t1 = new Thread(runnable); t1.start();`
    - 자바 JVM은 **유저 스레드(User Thread)** 를 생성하고, 운영체제에 스레드 실행 요청
- **운영체제**: 소프트웨어 스레드를 **커널 스레드(Kernel Thread)** 로 관리하고, 적절한 하드웨어 스레드에 할당
- **CPU**: 운영체제의 스케줄러에 의해 할당된 하드웨어 스레드에서 **물리적으로** 코드 실행


## 참고
[wikidoc](https://wikidocs.net/63816) 


[공룡책](#)
