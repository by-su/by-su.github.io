---
title: "Redis ìºì‹œì™€ íŠ¸ëœì­ì…˜: Race Conditionê³¼ ë°ì´í„° ë¶ˆì¼ì¹˜ í•´ê²°í•˜ê¸°"
excerpt: "Spring Bootì—ì„œ Redis ìºì‹œì™€ íŠ¸ëœì­ì…˜ì„ í•¨ê»˜ ì‚¬ìš©í•  ë•Œ ë°œìƒí•˜ëŠ” Race Condition, ìºì‹œ-DB ë¶ˆì¼ì¹˜, ë¡¤ë°± ì‹œ ìºì‹œ ì˜¤ì—¼ ë¬¸ì œì™€ ì›ìì  ì¿¼ë¦¬, ë¹„ê´€ì /ë‚™ê´€ì  ë½ì„ í™œìš©í•œ
ì‹¤ë¬´ í•´ê²°ì±…ì„ ì†Œê°œí•©ë‹ˆë‹¤."
permalink: /redis-cache-transaction-problems/
categories: [Backend, Spring, Redis]
tags: [Redis, Cache, Transaction, Race-Condition, Spring-Boot, JPA, Kotlin, ë™ì‹œì„±]
image:
  path: /assets/img/posts/redis-transaction.png
toc: true
---
# Redis ìºì‹œì™€ íŠ¸ëœì­ì…˜: Race Conditionê³¼ ë°ì´í„° ë¶ˆì¼ì¹˜ í•´ê²°í•˜ê¸°

## ë¬¸ì œ ìƒí™©

ìƒí’ˆ ì¡°íšŒìˆ˜ë¥¼ ì¦ê°€ì‹œí‚¤ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ë©´ì„œ Redis ìºì‹œì™€ íŠ¸ëœì­ì…˜ì„ í•¨ê»˜ ì‚¬ìš©í•  ë•Œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ë¬¸ì œê°€ ë³´ì—¬ ì´ë¥¼ ì¢€ ìì„¸í•˜ê²Œ ë¶„ì„í•´ë³´ë ¤ê³  í•©ë‹ˆë‹¤.
```kotlin
@Transactional
@CachePut(cacheNames = ["product"], key = "#id")  
fun updateProduct(id: Long): Product {  
    val product = productRepository.findById(id).orElseThrow {  
        throw EntityNotFoundException("ìƒí’ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")  
    }  
  
    product.views++  
    return product  
}
```

## ë°œê²¬ëœ ë¬¸ì œë“¤

ìœ„ ì½”ë“œì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë¬¸ì œê°€ ë°œìƒí•©ë‹ˆë‹¤:

### 1. Race Condition (ì½ê¸°-ì“°ê¸° ê²½ìŸ ì¡°ê±´)
```
Thread 1: views = 100 ì½ìŒ
Thread 2: views = 100 ì½ìŒ
Thread 1: views = 101ë¡œ ì—…ë°ì´íŠ¸
Thread 2: views = 101ë¡œ ì—…ë°ì´íŠ¸ (102ê°€ ë˜ì–´ì•¼ í•¨)
```

### 2. ìºì‹œ-DB ë¶ˆì¼ì¹˜ ë¬¸ì œ
ë™ì‹œì„± ë¬¸ì œë¡œ ì¸í•´ ìºì‹œì™€ ë°ì´í„°ë² ì´ìŠ¤ì˜ ë°ì´í„°ê°€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 3. íŠ¸ëœì­ì…˜ ë¡¤ë°± ì‹œ ìºì‹œ ì˜¤ì—¼
> @CachePutì€ ë©”ì„œë“œ ì‹¤í–‰ í›„ ìºì‹œë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ”ë°, íŠ¸ëœì­ì…˜ì´ ë¡¤ë°±ë˜ë©´ ìºì‹œì—ëŠ” ì˜ëª»ëœ ë°ì´í„°ê°€ ë‚¨ê²Œ ë©ë‹ˆë‹¤.


## í•´ê²° ë°©ë²•

### 1. Race Condition í•´ê²°
#### ë°©ë²• 1: ì›ìì  ì¿¼ë¦¬
```
@Query(value = """
    UPDATE product 
    SET views = views + 1 
    WHERE id = :id 
    RETURNING *
""", nativeQuery = true)
fun incrementAndReturn(@Param("id") id: Long): Product?
```
**PostgreSQLì˜ ê²½ìš°:** RETURNING êµ¬ë¬¸ì„ ì‚¬ìš©í•˜ì—¬ ê°„ë‹¨í•˜ê²Œ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```kotlin
@Repository
interface ProductNativeDao {
    @Modifying
    @Query(value = "UPDATE product SET views = LAST_INSERT_ID(views + 1) WHERE id = :id", nativeQuery = true)
    fun bump(@Param("id") id: Long): Int

    @Query(value = "SELECT LAST_INSERT_ID()", nativeQuery = true)
    fun lastInserted(): Long
}

@Transactional
fun increaseViewsAndGet(id: Long): Long {
    if (dao.bump(id) == 0) throw EntityNotFoundException()
    return dao.lastInserted()   // ì •í™•íˆ 3
}

```
**MySQLì˜ ê²½ìš°:** `LAST_INSERT_ID()`ë¥¼ í™œìš©í•œ ìš°íšŒ ë°©ë²•ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.


#### ë°©ë²• 2: ë¹„ê´€ì  ë½ (Pessimistic Lock)
```kotlin
interface ProductRepository : JpaRepository<Product, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("select p from Product p where p.id = :id")
    fun findForUpdate(@Param("id") id: Long): Product?
}

@Transactional
fun increaseViewsPessimistic(id: Long): Product {
    val p = productRepository.findForUpdate(id) ?: throw EntityNotFoundException()
    p.views += 1
    return p
}
```
- `@Lock(PESSIMISTIC_WRITE)`(= DBì˜ `SELECT â€¦ FOR UPDATE`)ê°€ ì‹¤í–‰ë˜ëŠ” **ê·¸ ìˆœê°„** í–‰(ë˜ëŠ” ì¸ë±ìŠ¤ ë ˆì½”ë“œ)ì´ ì ê¸°ê³  **íŠ¸ëœì­ì…˜ì´ ëë‚  ë•Œ(ì»¤ë°‹/ë¡¤ë°±)** ê¹Œì§€ ìœ ì§€ë©ë‹ˆë‹¤.
- **ì¥ì **: í™•ì‹¤í•œ ë™ì‹œì„± ì œì–´
- **ë‹¨ì **: ì„±ëŠ¥ ì €í•˜ ê°€ëŠ¥ì„±, ë°ë“œë½ ìœ„í—˜


#### ë°©ë²• 3: ë‚™ê´€ì  ë½ (Optimistic Lock)
```kotlin
@Entity
class Product(
    @Id val id: Long,
    val name: String,
    var views: Long = 0,
    @Version var version: Long? = null
)

@Transactional
fun increaseViewsOptimistic(id: Long): Product {
    repeat(3) { attempt ->
        val p = productRepository.findById(id).orElseThrow { EntityNotFoundException() }
        p.views += 1
        try {
            productRepository.saveAndFlush(p) // flush ì‹œ ì¶©ëŒë‚˜ë©´ ì˜ˆì™¸
            return p
        } catch (e: ObjectOptimisticLockingFailureException) {
            if (attempt == 2) throw e // 3íšŒ ì‹¤íŒ¨ ì‹œ í¬ê¸°
        }
    }
    error("unreachable")
}
```

- **ì¥ì **: ë†’ì€ ë™ì‹œì„± ì§€ì›
- **ë‹¨ì **: ì¶©ëŒ ì‹œ ì¬ì‹œë„ ë¡œì§ í•„ìš”

### 2. ìºì‹œ-DB ë¶ˆì¼ì¹˜ í•´ê²°
#### ë°©ë²• 1: ì»¤ë°‹ í›„ ë¬´íš¨í™”(Evict-on-Commit)

```kotlin
@Transactional
@CacheEvict(cacheNames = ["product"], key = "#id")  
fun updateProduct(id: Long): Product {  
    ...
    return product  
}
```

#### ë°©ë²• 2: ì»¤ë°‹ í›„ ì¬ì ì¬

```kotlin
@Transactional
fun increaseViews(id: Long): Long {
    val updated = productRepository.incrementViews(id)
    if (updated == 0) throw EntityNotFoundException()

    val newValue = productNativeDao.lastInserted() // í˜¹ì€ RETURNINGìœ¼ë¡œ ë°›ì€ ê°’

    TransactionSynchronizationManager.registerSynchronization(object : TransactionSynchronization {
        override fun afterCommit() {
            val fresh = productRepository.findById(id).orElse(null) ?: return
            cacheManager.getCache("product")?.put(id, fresh)
            cacheManager.getCache("popularProducts")?.clear()
        }
    })
    return newValue
}
```


> ğŸ“Œ **ì°¸ê³ **: ì´ ë°©ë²•ì„ ì‚¬ìš©í•˜ë©´ @CachePut ëŒ€ì‹  ìˆ˜ë™ìœ¼ë¡œ ìºì‹œë¥¼ ê´€ë¦¬í•˜ê²Œ ë©ë‹ˆë‹¤.

### 3. íŠ¸ëœì­ì…˜ ì•ˆì „ì„± ë³´ì¥
#### ë°©ë²• 1: ì»¤ë°‹ í›„ ìºì‹œ ë°©ì¶œ(Evict)í•˜ê¸°
```kotlin
@Transactional
fun updateProductName(id: Long, newName: String) {
    val p = productRepository.findById(id).orElseThrow()
    p.name = newName

    TransactionSynchronizationManager.registerSynchronization(object : TransactionSynchronization {
        override fun afterCommit() {
            cacheManager.getCache("product")?.evict(id)
            cacheManager.getCache("popularProducts")?.clear()
        }
    })
}

```
- DB ì»¤ë°‹ì´ ì„±ê³µí•œ ë’¤ì— ìºì‹œë¥¼ ë°©ì¶œí•©ë‹ˆë‹¤. ë¡¤ë°±ë˜ë©´ ì‹¤í–‰ë˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ìºì‹œ-DB ë¶ˆì¼ì¹˜ë¥¼ í™•ì‹¤í•˜ê²Œ ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


#### ë°©ë²• 2: TransactionAwareCacheManagerProxy ì‚¬ìš©í•˜ê¸°

@CacheEvict ì–´ë…¸í…Œì´ì…˜ì—ë„ íŠ¸ëœì­ì…˜ ë™ê¸°í™”ë¥¼ ì ìš©í•˜ë ¤ë©´, CacheManagerë¥¼ ë¹ˆìœ¼ë¡œ ë“±ë¡í•  ë•Œ TransactionAwareCacheManagerProxyë¡œ ê°ì‹¸ì„œ ë“±ë¡í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ìºì‹œ ì—°ì‚°ì´ ìë™ìœ¼ë¡œ íŠ¸ëœì­ì…˜ì— ë™ê¸°í™”ë©ë‹ˆë‹¤.
```kotlin
@Bean
fun cacheManager(connectionFactory: RedisConnectionFactory): CacheManager {
    val redisCacheManager = RedisCacheManager.builder(connectionFactory).build()
    return TransactionAwareCacheManagerProxy(redisCacheManager)
}
```

## ê²°ë¡ 

Redis ìºì‹œì™€ íŠ¸ëœì­ì…˜ì„ í•¨ê»˜ ì‚¬ìš©í•  ë•ŒëŠ” ë‹¤ìŒ ì‚¬í•­ë“¤ì„ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤:

### ì„±ëŠ¥ vs ì¼ê´€ì„±
- **ì›ìì  ì¿¼ë¦¬**: ê°€ì¥ íš¨ìœ¨ì ì´ì§€ë§Œ DB ì¢…ë¥˜ì— ë”°ë¼ ì œì•½
- **ë¹„ê´€ì  ë½**: í™•ì‹¤í•˜ì§€ë§Œ ì„±ëŠ¥ ì €í•˜ ê°€ëŠ¥
- **ë‚™ê´€ì  ë½**: ë†’ì€ ë™ì‹œì„±ì´ì§€ë§Œ ì¶©ëŒ ì²˜ë¦¬ ë³µì¡


