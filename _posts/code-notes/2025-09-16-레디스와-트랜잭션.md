---
title: "Redis 캐시와 트랜잭션: Race Condition과 데이터 불일치 해결하기"
excerpt: "Spring Boot에서 Redis 캐시와 트랜잭션을 함께 사용할 때 발생하는 Race Condition, 캐시-DB 불일치, 롤백 시 캐시 오염 문제와 원자적 쿼리, 비관적/낙관적 락을 활용한
실무 해결책을 소개합니다."
permalink: /redis-cache-transaction-problems/
categories: [Backend, Spring, Redis]
tags: [Redis, Cache, Transaction, Race-Condition, Spring-Boot, JPA, Kotlin, 동시성]
image:
  path: /assets/img/posts/redis-transaction.png
toc: true
---
# Redis 캐시와 트랜잭션: Race Condition과 데이터 불일치 해결하기

## 문제 상황

상품 조회수를 증가시키는 기능을 구현하면서 Redis 캐시와 트랜잭션을 함께 사용할 때 발생할 수 있는 문제가 보여 이를 좀 자세하게 분석해보려고 합니다.
```kotlin
@Transactional
@CachePut(cacheNames = ["product"], key = "#id")  
fun updateProduct(id: Long): Product {  
    val product = productRepository.findById(id).orElseThrow {  
        throw EntityNotFoundException("상품을 찾을 수 없습니다.")  
    }  
  
    product.views++  
    return product  
}
```

## 발견된 문제들

위 코드에서는 다음과 같은 문제가 발생합니다:

### 1. Race Condition (읽기-쓰기 경쟁 조건)
```
Thread 1: views = 100 읽음
Thread 2: views = 100 읽음
Thread 1: views = 101로 업데이트
Thread 2: views = 101로 업데이트 (102가 되어야 함)
```

### 2. 캐시-DB 불일치 문제
동시성 문제로 인해 캐시와 데이터베이스의 데이터가 일치하지 않을 수 있습니다.

### 3. 트랜잭션 롤백 시 캐시 오염
> @CachePut은 메서드 실행 후 캐시를 업데이트하는데, 트랜잭션이 롤백되면 캐시에는 잘못된 데이터가 남게 됩니다.


## 해결 방법

### 1. Race Condition 해결
#### 방법 1: 원자적 쿼리
```
@Query(value = """
    UPDATE product 
    SET views = views + 1 
    WHERE id = :id 
    RETURNING *
""", nativeQuery = true)
fun incrementAndReturn(@Param("id") id: Long): Product?
```
**PostgreSQL의 경우:** RETURNING 구문을 사용하여 간단하게 처리할 수 있습니다.

```kotlin
@Repository
interface ProductNativeDao {
    @Modifying
    @Query(value = "UPDATE product SET views = LAST_INSERT_ID(views + 1) WHERE id = :id", nativeQuery = true)
    fun bump(@Param("id") id: Long): Int

    @Query(value = "SELECT LAST_INSERT_ID()", nativeQuery = true)
    fun lastInserted(): Long
}

@Transactional
fun increaseViewsAndGet(id: Long): Long {
    if (dao.bump(id) == 0) throw EntityNotFoundException()
    return dao.lastInserted()   // 정확히 3
}

```
**MySQL의 경우:** `LAST_INSERT_ID()`를 활용한 우회 방법을 사용합니다.


#### 방법 2: 비관적 락 (Pessimistic Lock)
```kotlin
interface ProductRepository : JpaRepository<Product, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("select p from Product p where p.id = :id")
    fun findForUpdate(@Param("id") id: Long): Product?
}

@Transactional
fun increaseViewsPessimistic(id: Long): Product {
    val p = productRepository.findForUpdate(id) ?: throw EntityNotFoundException()
    p.views += 1
    return p
}
```
- `@Lock(PESSIMISTIC_WRITE)`(= DB의 `SELECT … FOR UPDATE`)가 실행되는 **그 순간** 행(또는 인덱스 레코드)이 잠기고 **트랜잭션이 끝날 때(커밋/롤백)** 까지 유지됩니다.
- **장점**: 확실한 동시성 제어
- **단점**: 성능 저하 가능성, 데드락 위험


#### 방법 3: 낙관적 락 (Optimistic Lock)
```kotlin
@Entity
class Product(
    @Id val id: Long,
    val name: String,
    var views: Long = 0,
    @Version var version: Long? = null
)

@Transactional
fun increaseViewsOptimistic(id: Long): Product {
    repeat(3) { attempt ->
        val p = productRepository.findById(id).orElseThrow { EntityNotFoundException() }
        p.views += 1
        try {
            productRepository.saveAndFlush(p) // flush 시 충돌나면 예외
            return p
        } catch (e: ObjectOptimisticLockingFailureException) {
            if (attempt == 2) throw e // 3회 실패 시 포기
        }
    }
    error("unreachable")
}
```

- **장점**: 높은 동시성 지원
- **단점**: 충돌 시 재시도 로직 필요

### 2. 캐시-DB 불일치 해결
#### 방법 1: 커밋 후 무효화(Evict-on-Commit)

```kotlin
@Transactional
@CacheEvict(cacheNames = ["product"], key = "#id")  
fun updateProduct(id: Long): Product {  
    ...
    return product  
}
```

#### 방법 2: 커밋 후 재적재

```kotlin
@Transactional
fun increaseViews(id: Long): Long {
    val updated = productRepository.incrementViews(id)
    if (updated == 0) throw EntityNotFoundException()

    val newValue = productNativeDao.lastInserted() // 혹은 RETURNING으로 받은 값

    TransactionSynchronizationManager.registerSynchronization(object : TransactionSynchronization {
        override fun afterCommit() {
            val fresh = productRepository.findById(id).orElse(null) ?: return
            cacheManager.getCache("product")?.put(id, fresh)
            cacheManager.getCache("popularProducts")?.clear()
        }
    })
    return newValue
}
```


> 📌 **참고**: 이 방법을 사용하면 @CachePut 대신 수동으로 캐시를 관리하게 됩니다.

### 3. 트랜잭션 안전성 보장
#### 방법 1: 커밋 후 캐시 방출(Evict)하기
```kotlin
@Transactional
fun updateProductName(id: Long, newName: String) {
    val p = productRepository.findById(id).orElseThrow()
    p.name = newName

    TransactionSynchronizationManager.registerSynchronization(object : TransactionSynchronization {
        override fun afterCommit() {
            cacheManager.getCache("product")?.evict(id)
            cacheManager.getCache("popularProducts")?.clear()
        }
    })
}

```
- DB 커밋이 성공한 뒤에 캐시를 방출합니다. 롤백되면 실행되지 않기 때문에 캐시-DB 불일치를 확실하게 방지할 수 있습니다.


#### 방법 2: TransactionAwareCacheManagerProxy 사용하기

@CacheEvict 어노테이션에도 트랜잭션 동기화를 적용하려면, CacheManager를 빈으로 등록할 때 TransactionAwareCacheManagerProxy로 감싸서 등록합니다. 이렇게 하면 캐시 연산이 자동으로 트랜잭션에 동기화됩니다.
```kotlin
@Bean
fun cacheManager(connectionFactory: RedisConnectionFactory): CacheManager {
    val redisCacheManager = RedisCacheManager.builder(connectionFactory).build()
    return TransactionAwareCacheManagerProxy(redisCacheManager)
}
```

## 결론

Redis 캐시와 트랜잭션을 함께 사용할 때는 다음 사항들을 고려해야 합니다:

### 성능 vs 일관성
- **원자적 쿼리**: 가장 효율적이지만 DB 종류에 따라 제약
- **비관적 락**: 확실하지만 성능 저하 가능
- **낙관적 락**: 높은 동시성이지만 충돌 처리 복잡


