
## 이전 에러 코드
### 코드 베이스 
[ ErrorCode.class ]
```kotlin
enum class ErrorCode(
) {
    LOGIN_FAILED,
    PASSWORD_INCORRECT,
    CONFLICT_VALUE,
    ;

    companion object {
        fun getMessage(code: ErrorCode, message: String? = null): String {
            return when (code) {
                LOGIN_FAILED -> "Login Information is incorrect"
                PASSWORD_INCORRECT -> "Password is incorrect"
                CONFLICT_VALUE -> "Duplicated $message"
            }
        }
    }
}

fun ErrorCode.toMessage(message: String? = null): String {
    return ErrorCode.getMessage(this, message)
}
```

[ CustomException.class ]
```kotlin
open class CustomException : RuntimeException {
    private val error: ErrorCode?
    private val code: String
    final override val message: String
    
    constructor(error: ErrorCode) : super(error.toMessage()) {
        this.error = error
        this.code = error.name
        this.message = error.toMessage()
    }

    constructor(code: String, message: String) : super(message) {
        this.error = null
        this.code = code
        this.message = message
    }

    open fun getErrorCode(): String = code

    open fun getErrorMessage(): String = message
}
```

[ ControllerAdvice.class ]
```kotlin
@ResponseBody
@ResponseStatus(HttpStatus.BAD_REQUEST)
@ExceptionHandler(value = [MethodArgumentNotValidException::class])
fun onValidationException(e: MethodArgumentNotValidException): ErrorResponse<String> {
    val errors = e.bindingResult.allErrors.associate { error ->
        val fieldName = if (error is FieldError) error.field else "globalError"
        val errorMessage = error.defaultMessage ?: "Invalid value"
        fieldName to errorMessage
    }
    return ErrorResponse(HttpStatus.BAD_REQUEST, ErrorCode.INVALID_VALUE.name, errors.toString())
}

@ResponseBody
@ResponseStatus(HttpStatus.BAD_REQUEST)
@ExceptionHandler(value = [IllegalArgumentException::class])
fun onIllegalArgumentException(e: IllegalArgumentException): ErrorResponse<String> {
    return ErrorResponse(HttpStatus.BAD_REQUEST, ErrorCode.INVALID_VALUE.name, e.message ?: "Invalid value")
}
```

### 문제점
[ 1. 동적 메시지 주입의 강제성이 없다 ]
```
accountRepository.findByEmailAndDeletedFalse(request.email)?.let {
    throw ConflictException(ErrorCode.CONFLICT_VALUE.name)
}
```
예를 들어 위 코드처럼 "email"이 중복된 경우라면, 클라이언트에게 어떤 값이 중복되었는지 명확히 전달하는 것이 중요하다.
하지만 현재 구조에서는 해당 정보를 넣지 않아도 예외가 발생해버리고, 이 경우 "Duplicated"라는 불완전한 메시지가 전달된다.
즉, 필수적으로 전달돼야 할 동적 메시지를 컴파일 타임에 강제할 방법이 없다.
<br><br>

[ 2. `ErrorCode`가 단순 데이터 역할만 하고 있다 ]

 현재는 enum 자체로는 데이터 컨테이너 역할에 그치고, 공통된 기능 제공이 전무하다. ResponseEntity 변환, ErrorResponse DTO 변환 등의 반복적인 기능을 컨트롤러/서비스가 각자 구현해야 한다. 책임과 역할의 불분명성으로 이어지고, 코드 중복 및 확장성 저하로 직결된다.


## 개선 방향
1. 정적 메시지(FixedMessage)와 동적 메시지(DynamicMessage)를 명확히 구분하여, 동적 메시지의 경우 반드시 필요한 파라미터가 주입되도록 타입 레벨에서 강제한다.
2. 에러 코드가 단순한 데이터 덩어리가 아닌, 기능을 내장한 객체가 되도록 설계한다.
    - 일관된 ErrorResponse 생성
    - 불필요한 코드 중복 제거 & 확장성 강화.

### 개선된 ErrorCode 클래스
ErrorCode라는 클래스 이름이 부적절한 것 같아 ErrorDescriptor로 변경하였다. 
```kotlin
sealed class ErrorDescriptor {

    abstract val code: String
    abstract val httpStatus: HttpStatus
    abstract fun resolveMessage(args: Map<String, String> = emptyMap()): String

    /** ResponseEntity 변환 */
    fun toResponseEntity(
        args: Map<String, String> = emptyMap(),
        path: String
    ): ResponseEntity<ErrorResponse> =
        ResponseEntity.status(httpStatus).body(
            ErrorResponse(
                httpStatus = httpStatus.value(),
                code = code,
                message = resolveMessage(args),
                path = path,
            )
        )

    /** 로그 포맷 */
    fun logFormat(args: Map<String, String> = emptyMap()): String =
        "[${httpStatus.value()}][$code] ${resolveMessage(args)}"

    /** FixedMessage → 고정 메시지 */
    data class FixedMessage(
        override val code: String,
        private val message: String,
        override val httpStatus: HttpStatus
    ) : ErrorDescriptor() {
        override fun resolveMessage(args: Map<String, String>): String = message
    }

    /** DynamicMessage → 다중 arg 대응 */
    data class DynamicMessage(
        override val code: String,
        override val httpStatus: HttpStatus,
        private val messageTemplate: String
    ) : ErrorDescriptor() {
        override fun resolveMessage(args: Map<String, String>): String {
            var result = messageTemplate
            args.forEach { (key, value) ->
                result = result.replace("{$key}", value)
            }
            return result
        }
    }

    companion object {
        fun fixed(code: String, message: String, httpStatus: HttpStatus) =
            FixedMessage(code, message, httpStatus)

        fun dynamic(code: String, httpStatus: HttpStatus, messageTemplate: String) =
            DynamicMessage(code, httpStatus, messageTemplate)
    }
}
```
1. 고정 메시지(FixedMessage)와 동적 메시지(DynamicMessage) 구분
    - 동적 메시지 사용 시 반드시 args를 전달해야 제대로 동작 → 타입으로 안전성 보장.
    - 실수로 메시지 누락 시 컴파일 타임 혹은 테스트 단계에서 발견 가능.

2. ErrorDescriptor가 하나의 풍부한 객체로서 기능 내장
    - ResponseEntity 변환, ErrorResponse 생성 모두 ErrorDescriptor 내부에 집약.
    - 클라이언트 응답, 로그 작성 등에서 중복 제거 및 일관성 확보.

3. sealed class로 상속 범위 제한
    - 외부에서 함부로 확장 불가 → 클래스 설계 안정성 확보.


### 추가된 ErrorCodes 클래스 
여러 곳에서 직접 fixed, dynamic을 통해 인스턴스를 생성하면 관리 포인트가 분산된다. 따라서 `object` 싱글턴 객체로 모든 에러 코드를 한 곳에서 선언/관리하여 유지보수를 용이하게 한다.
```kotlin
object ErrorCodes {
    val NOT_FOUND = ErrorDescriptor.dynamic(
        code = "NOT_FOUND",
        httpStatus = HttpStatus.NOT_FOUND,
        messageTemplate = "{value}를 찾을 수 없습니다."
    )
}
```

### ControllerAdvice 클래스
```kotlin

@RestControllerAdvice
class GeneralControllerAdvice {

    private val logger = LoggerFactory.getLogger(GeneralControllerAdvice::class.java)

    /**
     * http status: 500 AND result: FAIL
     * System exception situation. Subject to intensive monitoring
     *
     * @param e
     * @return
     */
    @ResponseBody
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    @ExceptionHandler(value = [Exception::class])
    fun onException(e: Exception, request: HttpServletRequest): String? {
        logger.error(
            "[UnhandledException] path=${request.requestURI}, error=${e.message}",
            e // stack trace
        )
        return "An unknown error occurred. Please try again."
    }

    /**
     * Handles CustomException and returns a ResponseEntity with an ErrorResponse.
     *
     * @param ex the CustomException to handle
     * @return a ResponseEntity containing the ErrorResponse
     */
    @ExceptionHandler(CustomException::class)
    fun handleCustomException(ex: CustomException, request: HttpServletRequest): ResponseEntity<ErrorResponse> {
        logger.warn(
            "[CustomException] code=${ex.errorDescriptor.code}, " +
                    "status=${ex.errorDescriptor.httpStatus}, " +
                    "message=${ex.errorDescriptor.resolveMessage(ex.args)}, " +
                    "path=${request.requestURI}"
        )
        return ex.errorDescriptor.toResponseEntity(ex.args, request.requestURI)
    }
}
```

## 추후 추가할 기능
- 다국어 지원