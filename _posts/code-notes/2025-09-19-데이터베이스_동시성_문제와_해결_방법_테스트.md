---
title: "데이터베이스 동시성 문제와 해결방법: 원자적 연산, 비관적 락, 낙관적 락 비교"
excerpt: "200개 동시 요청 환경에서 Lost Update 문제를 재현하고, 원자적 연산, 비관적 락, 낙관적 락 각각의 성능과 정확성을 실제 테스트 코드로 검증한 결과를 비교 분석합니다."
permalink: /동시성-문제/
categories: [Backend, Database, Spring, 코드고민]
tags: [동시성, Race-Condition, 원자적-연산, 비관적-락, 낙관적-락, JPA, Kotlin, Lost-Update, 트랜잭션]
image:
  path: /assets/covers/concurrency.png
toc: true
---

## 관련 글
- [레디스와 트랜잭션]({% post_url code-notes/2025-09-16-레디스와-트랜잭션 %})

이전에 얘기한 레디스 캐시를 할 때 1번에서 발생한 Race condition문제를 검증하고 해결 방법에 대한 테스트도 작성해보려고 합니다. 레디스까지 연동은 하지 않고 RDBMS만 테스트 해보겠습니다.

## Race Condition 발생

동시성 환경에서 여러 스레드가 같은 데이터를 동시에 수정할 때 발생하는 Lost Update 문제를 테스트해보겠습니다.


```kotlin
@Testcontainers  
@SpringBootTest  
class ProductServiceTest(  
    private val productService: ProductService,  
    private val productRepository: ProductRepository,  
    @param:Autowired private val entityManager: EntityManager,  
): FunSpec({  

	companion object {
	    private const val DEFAULT_THREAD_COUNT = 200  // 동시 실행할 스레드 수
	    private const val THREAD_POOL_SIZE = 16      // 스레드 풀 크기
	    private const val TIMEOUT_SECONDS = 30L      // 테스트 타임아웃
    }
    
    test("동시성 환경에서 Lost Update 문제 검증") {  
	    val updatedProduct = executeConcurrentTest { id ->  
	        productService.updateProduct(id)  
	    }  
	  
	    println("실제 조회수: ${updatedProduct.views}")
	    // 200번 호출했지만 실제로는 훨씬 적은 수만 업데이트됨을 검증
	    updatedProduct.views shouldBeLessThan DEFAULT_THREAD_COUNT  
	}
    
    fun executeConcurrentTest(  
        threadCount: Int = DEFAULT_THREAD_COUNT,  
        operation: (Long) -> Unit  
    ): Product {  
        val testProduct = createTestProduct()
        val pool = Executors.newFixedThreadPool(THREAD_POOL_SIZE)
        // 모든 스레드가 동시에 시작하도록 하는 CountDownLatch
        val startGate = CountDownLatch(1)
        // 모든 작업 완료를 기다리는 CountDownLatch
        val doneGate = CountDownLatch(threadCount)  
  
        // 200개의 스레드를 생성하여 동시에 실행 준비
        repeat(threadCount) {
            pool.submit {
                startGate.await()  // startGate가 열릴 때까지 대기
                try {
                    operation(testProduct.id!!)
                } finally {
                    doneGate.countDown()  // 작업 완료 신호
                }
            }
        }
        // 모든 스레드를 동시에 시작
        startGate.countDown()  
        val finished = doneGate.await(TIMEOUT_SECONDS, TimeUnit.SECONDS)  
        pool.shutdown()  
  
        require(finished) { "작업이 시간 내에 끝나지 않았습니다." }  
  
        // 영속성 컨텍스트를 클리어하여 DB에서 최신 데이터 조회
        entityManager.clear()
        return productRepository.findById(testProduct.id!!).orElseThrow()  
    }
    
    fun createTestProduct(): Product {  
        return productRepository.save(Product(name = "race", views = 0))  
    }  
    
}
```


![image](https://rootbly-images.s3.ap-northeast-2.amazonaws.com/notes/3dc42cc1499091de53862a82a392fdd3.png)
- 실제 조회수가 21로 나오며 200개 중에 21개면 Race Condition 문제가 얼마나 심각하지 알 수 있습니다.


## 해결방법 1: 원자적 연산 (Atomic Operation)

이를 해결하기 위해 MySQL의 `LAST_INSERT_ID()` 함수를 활용한 원자적 연산을 사용해보겠습니다. 이 방법은 단일 SQL 쿼리로 값을 증가시키고 업데이트된 값을 반환합니다.
```kotlin
interface ProductRepository: JpaRepository<Product, Long> {  
  
    @Modifying
    @Query(value = "UPDATE product SET views = LAST_INSERT_ID(views + 1) WHERE id = :id", nativeQuery = true)
    fun bump(@Param("id") id: Long): Int  // 업데이트된 행의 수를 반환

    @Query(value = "SELECT LAST_INSERT_ID()", nativeQuery = true)
    fun lastInserted(): Long  // 마지막으로 업데이트된 views 값을 반환  
}

@Service
@Transactional(readOnly = true)
class ProductService (
	private val productRepository: ProductRepository
) {
	@Transactional
	fun increaseViewsAndGet(id: Long): Long {
	    // 업데이트 실행 후 영향받은 행 수 확인
	    if (productRepository.bump(id) == 0) throw EntityNotFoundException()
	    // 업데이트된 views 값 반환
	    return productRepository.lastInserted()
	}
}
```

테스트 코드 추가
```kotlin
test("원자적 연산으로 동시성 문제 해결 검증") {  
    val updatedProduct = executeConcurrentTest { id ->  
        productService.increaseViewsAndGet(id)  
    }  
  
    println("실제 조회수: ${updatedProduct.views}")  
    updatedProduct.views shouldBe DEFAULT_THREAD_COUNT  
}
```

![image](https://rootbly-images.s3.ap-northeast-2.amazonaws.com/notes/97b2e9c9596dec546c8d340684dfac93.png)
- 200개 잘 조회되었음을 확인할 수 있습니다.



## 해결방법 2: 비관적 락 (Pessimistic Lock)

비관적 락은 데이터를 읽을 때 다른 트랜잭션이 해당 데이터를 수정하지 못하도록 미리 락을 걸어두는 방식입니다. `SELECT ... FOR UPDATE` 구문을 사용합니다.
```kotlin
@Service  
class PessimisticLockProductService(  
    private val pessimisticLockProductRepository: PessimisticLockProductRepository  
) {  
  
    @Transactional
    fun increaseViewPessimistic(id: Long): PessimisticLockProduct {
        // SELECT ... FOR UPDATE로 행 수준 락을 획득
        val product = pessimisticLockProductRepository.findByIdForUpdate(id).let {
            it?.views++
            return it!!
        } ?: {
            throw EntityNotFoundException("상품을 찾을 수 없습니다.")
        }
    }  
  
}

interface PessimisticLockProductRepository: JpaRepository<PessimisticLockProduct, Long> {  
  
    // 행 잠금: SELECT ... FOR UPDATE
    @Lock(LockModeType.PESSIMISTIC_WRITE)  // 쓰기 락 설정
    @Query("select p from PessimisticLockProduct p where p.id = :id")
    fun findByIdForUpdate(@Param("id") id: Long): PessimisticLockProduct?  
}
```

view 카운트가 200으로 정상적으로 업데이트되었음을 확인할 수 있습니다. 원자적 연산보다 200ms 더 빠르네요.
![image](https://rootbly-images.s3.ap-northeast-2.amazonaws.com/notes/8626ed98f2d5956a7e747f930820224c.png)




## 해결방법 3: 낙관적 락 (Optimistic Lock)

낙관적 락은 데이터를 읽을 때는 락을 걸지 않고, 업데이트할 때 버전을 확인하여 충돌을 감지하는 방식입니다. `@Version` 어노테이션을 사용합니다.

```kotlin
@Entity
class OptimisticLockProduct(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    val name: String,
    var views: Int,
    @Version  // JPA가 자동으로 버전 관리
    var version: Long? = null
) {
}

@Service  
class OptimisticLockProductService(  
    private val optimisticLockRepository: OptimisticLockRepository  
) {  
  
    @Transactional
    fun increaseViewOptimistic(id: Long): OptimisticLockProduct {
        val product = optimisticLockRepository.findById(id).orElseThrow {
            EntityNotFoundException("상품을 찾을 수 없습니다. id=$id")
        }
        product.views++
        // 트랜잭션 커밋 시점에 version이 변경되었다면 OptimisticLockingFailureException 발생
        return product
    }  
  
}
```

### 낙관적 락 기본 테스트 결과
292ms로 처리는 빠르지만 21개의 view 카운트만 증가되었습니다. 대부분의 요청이 `OptimisticLockingFailureException`으로 실패했음을 의미합니다.
![image](https://rootbly-images.s3.ap-northeast-2.amazonaws.com/notes/3093463d5c382b91469165e93a9e0738.png)

이거는... 락을 도입하지 않았을 때랑 똑같은 결과라 Retry로직을 추가해 테스트 해보겠습니다.

### 재시도 로직 적용
```kotlin
@Retryable(
	value = [OptimisticLockingFailureException::class],
	maxAttempts = 3,
	backoff = Backoff(delay = 100, multiplier = 2.0)
)
@Transactional
fun increaseViewOptimistic(id: Long): OptimisticLockProduct {
	val product = optimisticLockRepository.findById(id).orElseThrow {
		EntityNotFoundException("상품을 찾을 수 없습니다. id=$id")
	}
	product.views++
	// 트랜잭션 커밋 시점에 version이 변경되었다면 OptimisticLockingFailureException 발생
	return product
}  
```

재시도 로직을 넣었을 때는 195로 어느정도 200에 가까워졌지만 1.284초가 걸렸습니다. 재시도로 인해 성공률은 높아졌지만 응답 시간이 크게 증가했습니다.
![image](https://rootbly-images.s3.ap-northeast-2.amazonaws.com/notes/7d00bb0799d40f6b3f0ca58811499a8a.png)

### 지연 시간을 둔 테스트
CountDownLatch를 사용하면 완전 동시에 요청이 가기 때문에 낙관적 락에는 불리할 것 같아 지연시간을 두고 실행해보았습니다.
```kotlin
repeat(DEFAULT_THREAD_COUNT) { index ->
    val delay = Random.nextLong(0, 51) // 0-50ms 랜덤 지연
    scheduler.schedule({
        try {
            service.increaseViewOptimistic(newProduct.id!!)
        } finally {
            doneGate.countDown()
        }
    }, delay, TimeUnit.MILLISECONDS)
}
```

72개만 증가되었습니다. 지연 시간을 두어도 여전히 많은 요청이 실패했습니다.
![image](https://rootbly-images.s3.ap-northeast-2.amazonaws.com/notes/fc46246f5358c799593df615017b352b.png)

## 결론

| 방법     | 성능          | 정확성    | 적용 상황              |
| ------ | ----------- | ------ | ------------------ |
| 원자적 연산 | 보통          | 완벽     | 단순한 증감 연산          |
| 비관적 락  | 보통          | 완벽     | 복잡한 비즈니스 로직, 충돌 빈발 |
| 낙관적 락  | 빠름(충돌 시 느림) | 재시도 필요 | 충돌이 적은 환경          |

짧은 시간에 많은 사용자가 동시 접근하는 경우 낙관적 락은 좋은 해결책이 아님을 확인할 수 있었습니다. 
