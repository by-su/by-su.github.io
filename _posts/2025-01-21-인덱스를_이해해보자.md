---
published: false
---



MySQL 성능 최적화 

MySQL의 성능 향상을 위한 두 가지 방법이 존재한다. 

첫 번째는 하드웨어의 성능을 늘리는 것이다. 이 방법은 고성능의 하드웨어를 쓸 수록 가격이 기하급수적으로 증가한다. 또 하드웨어 증설의 한계가 존재한다. 따라서 다음의 경우를 제외하고는 두 번째 방법을 따르는 것이 좋다.
1. 하드웨어 성능 부족으로 명백하게 느린거라면 적절한 성능의 하드웨어로 스케일업해야 한다. 
	 - (An important consideration for determining the amount of memory to allocate for a database is to make sure that the working set fits in the buffer pool. A working set is the data actively used at any moment by the database. ) 
	 - One way to check if enough memory has been allocated is to check the disk reads status in the database. Ideally disk reads should be less or very minimal under normal workload conditions.

2. 사용량이 급증하여 안정성을 담보하기 위한 임시 방편


위 두 가지 방법을 제외하고는 쿼리와 데이터, 접근 패턴, 애플리케이션을 최적화해야 한다.


## 클러스터 인덱스와 세컨더리 인덱스: 데이터 조회 과정 
클러스터 인덱스 조회 과정
```scss
  (1) 프라이머리 키 탐색 및 데이터 접근
        +-------------------+
        | Primary Index     |
        +-------------------+
                |
  +-------------+-------------+
  |                           |
(Key=1234)             (Key=5678)
    |                           |
+-------------------+   +-------------------+
| Data 1           |   | Data 2           |
| ID: 1234         |   | ID: 5678         |
| Name: John Doe   |   | Name: Jane Smith |
| Age: 30          |   | Age: 25          |
+-------------------+   +-------------------+

(2) 데이터 반환
   - ID: 1234, Name: John Doe, Age: 30

```



세컨더리 인덱스 조회 과정
```scss
  (1) 세컨더리 인덱스 탐색
        +-------------------+
        | Secondary Index   |
        +-------------------+
                |
  +-------------+-------------+
  |                           |
(Key=A1234)           (Key=B5678)
    |                           |
+-------+                 +-------+
| PK=1234|               | PK=5678|
+-------+                 +-------+

  (2) 프라이머리 키로 데이터 조회
        +-------------------+
        | Primary Index     |
        +-------------------+
                |
  +-------------+-------------+
  |                           |
(Key=1234)             (Key=5678)
    |                           |
+-------------------+   +-------------------+
| Data 1           |   | Data 2           |
| ID: 1234         |   | ID: 5678         |
| Name: John Doe   |   | Name: Jane Smith |
| Age: 30          |   | Age: 25          |
+-------------------+   +-------------------+

(3) 최종 데이터 반환
   - ID: 1234, Name: John Doe, Age: 30

```



Q. 왜 인덱스 스캔과 테이블 스캔은 피해야 할까요 !? 

Q. 행을 조회하는 세 가지 방법 ?







### 인덱스 스캔
- 인덱스 조회가 부족할 때 MySQL은 모든 행을 읽고 일치하지 않는 행을 필터링한다. MySQL은 프라이머리 키로 모든 행을 읽기 전에 세컨더리 인덱스로 행 읽기를 시도하는데 이를 `인덱스 스캔`이라고 한다. 

#### 풀 인덱스 스캔
- 인덱스 순서대로 행을 읽는다. 모든 행을 읽는 것은 일반적으로 성능에 매우 불리하지만 인덱스 순서가 ORDER BY쿼리와 일치하면 행 정렬을 피할 수 있다. 

참고: 세컨더리 인덱스를 순서대로 스캔하는 것은 순차일 수 있지만 프라이머리 키는 무작위 읽기이다. 

#### 인덱스 전용 스캔 
- 인덱스에서 열값(전체 행이 아님)을 읽는다. 이를 위해서는 커버링 인덱스가 필요하다. 전체 행을 읽기 위해 프라이머리 키 조회를 해야 하는 상황이 아니므로 풀 인덱스 스캔보다 빠르다. 


---- 유일한 대안이 풀 테이블 스캔이 아닌 이상 인덱스 스캔으로 최적화하지 말자. 


### 테이블 스캔 
- 풀 테이블 스캔은 프라이머리 키 순서로 모든 행을 읽는다. 


### 맨 왼쪽 접두사 요구사항
- 인덱스를 사용하려면 쿼리는 인덱스의 맨 왼쪽 접두사, 즉 인덱스정의에서 지정한 맨 왼쪽 인덱스 열로 시작하는 하나 이상의 인덱스 열을 반드시 사용해야 한다.  -> 기본적으로 인덱스 구조는 인덱스 열 순서에 따라 정렬되므로 맨 왼쪽 접두사가 필요하며 그 순서로만 탐색할 수 있다. 

(a, b, c) 인덱스가 있을 때 
1번 케이스: a = 'Au' AND b = 'Be' 
 -> 인덱스 (a, b)와 (b, a)는 다르다. 같은 열을 인덱싱하지만 순서가 달라서 맨 왼쪽 접두사가 다르며, 성능도 다르다.
  -> (a, b, c) 인덱스를 사용할 가능성이 더 크다. (a), (a, b) 2개는 (a, b, c)의 맨 왼쪽 접두사이기 때문이며 이때 인덱스 (a), (a, b)는 중복되어 삭제될 수 있다. 





## 팁

같지 않음(!=)연산을 사용하면 범위 접근 유형이 작동한다. 
 -> WHERE a != 5 
-> WHERE a < 5 or WHERE a > 5
-> 인덱스의 정렬된 특성을 활용해서 빠르게 범위 검색 가능 
```
전체 데이터: 
+----+----+----+----+----+----+----+----+----+----+----+
| 10 | 15 | 20 | 25 | 25 | 25 | 30 | 35 | 40 | 45 | 50 |
+----+----+----+----+----+----+----+----+----+----+----+
```

 -> 여기서 25는 모두 건너뛰기  때문에 유리






### Orderby
orderby를 최적화 하는 방법
1. 맨 왼쪽 접두사 사용하기
2. 인덱스 상수로 맨 오니쪽 부분을 유지하고 다음에 인덱스 열을 기준으로 정렬하는 것 
```
a = 'Ar' ORDER BY b
```
3. 두 번째의 특별한 방법으로 PK이용
```
where a = 'AI' AND b = 'B' ORDER BY id 
```


Extra필드의 `Using filesort` 는 행 정렬을 의미한다.  파일 정렬은 쿼리를 느리게 만들지 않는다. 
ORDER BY 최적화는 오름차순이든 내림차순이든 모든 열에 대해 한 방향으로만 작동한다. 결과적으로 ORDER Y a,b DESC에서 a열은 B desc와 달리 암시적 ASC정렬이므로 해당 정렬은 작동하지 않는다. 

### 인덱스 컨디션 푸시다운 (Using index condition)
- 스토리지 엔진이 인덱스를 사용하여 WHERE 조건과 일치하는 행을 찾는다 